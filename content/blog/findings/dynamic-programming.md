---
title: "Dynamic Programming"
date: "2020-07-10"
tags: ["seedlab", "lecture", "algorithm"]
---

# DP01. Introduction

## 1. 什么是DP

在计算机程序中通过统筹学的方法, 减少重复地运算过程以提高整体运算效率. 
更加具体来说, 是通过对整体计算过程和顺序的合理规划来避免重复的计算过程.
 
## 2. 一般问题

* 一般涉及的问题是求最值
* 最长递增子序列
* 最小编辑距离

## 3. 解题思想

#### 3.1 反向扩散

* 寻找问题的"子问题", 
* 保存之前计算中"子问题"的结果,
* 当需要在后面计算涉及到相同"子问题"时
* 直接使用计算的结果, 避免重复的计算.

#### 3.2 正向扩散

* 同样也是寻找"重叠子问题", 
* 从底层的问题扩散到更加复杂的问题, 
* 直到目标的问题停止计算. 

## 4. 解题范式

#### 4.1 范式思路

* 确定"重叠子问题", 
* 确保此问题满足"最优子结构"(指子问题之间必须相互独立互不影响), 
* 得到状态转化方程, 

#### 4.2 核心概念: 状态转化方程

* 确定"状态": 就是在整个算法变量的取值的不同组合(变量某种取值的组合就是一种状态, 状态机概念). 
* 确定"基础状态": 算法最小子问题的答案, 最小子问题就是说没有重叠子问题的子问题. 
* 确定"行为": 行为将会让算法从一个状态转化到另外一个状态. 
* 根据之前的状态确定算法的"DP"函数: DP函数就是将最终问题通过迭代式的函数表达成为子问题的方式. 

#### 4.3 范式内容

```C
//"基础状态"
dp[0][0][...] = base
//"行为"导致状态转化
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            //算法的"DP"函数
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

## 4. 声明

这是一篇个人笔记, 以上大部分内容来自GitHub上的[labuladong](https://labuladong.gitbook.io/algo/)的算法小册内容. 和一部分我的理解归纳

